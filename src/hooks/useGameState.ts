import React from "react";

export type Phase = 1 | 2 | 3;
export type Player = "a" | "b";
export type Occupancy = Player;
export type PointID = string;
export type Point = {
  neighbors: PointID[];
  occupancy?: Occupancy;
};
type StateGraph = Record<PointID, Point>;

interface Mill {
  points: PointID[];
  occupancy?: Occupancy;
}

// Initial state graph just defines adjacency. occupancy is omitted as there are no pieces to start
// This state graph represents the adjacency for 6 man morris (2 rings)
const initialStateGraph: StateGraph = {
  // inner ring
  a: { neighbors: ["b", "h"] },
  b: { neighbors: ["a", "c", "j"] },
  c: { neighbors: ["b", "d"] },
  d: { neighbors: ["c", "e", "l"] },
  e: { neighbors: ["d", "f"] },
  f: { neighbors: ["e", "g", "n"] },
  g: { neighbors: ["f", "h"] },
  h: { neighbors: ["g", "a", "p"] },

  // outer ring
  i: { neighbors: ["l", "p"] },
  j: { neighbors: ["i", "k", "b"] },
  k: { neighbors: ["j", "l"] },
  l: { neighbors: ["k", "m", "d"] },
  m: { neighbors: ["l", "m"] },
  n: { neighbors: ["m", "o", "f"] },
  o: { neighbors: ["n", "p"] },
  p: { neighbors: ["o", "i", "h"] },
};

// These represent the "lines" which a mill must be formed on. They could be autogenerated with a simple formula
// The advantage of storing this separately from the state graph is that it gives us flexibility in what makes a mill line.
const initialMills: Mill[] = [
  // inner ring
  { points: ["a", "b", "c"] },
  { points: ["c", "d", "e"] },
  { points: ["e", "f", "g"] },
  { points: ["g", "h", "a"] },

  // outer ring
  { points: ["i", "j", "k"] },
  { points: ["k", "l", "m"] },
  { points: ["m", "n", "o"] },
  { points: ["o", "p", "i"] },
];

const initialState: GameState = {
  phase: 1,
  turn: { count: 0, player: "a" },
  stateGraph: initialStateGraph,
  remainingMen: { a: 6, b: 6 },
  mills: initialMills,
};

export interface GameState {
  phase: Phase;
  turn: { count: number; player: Player };
  remainingMen: Record<Player, number>;
  stateGraph: StateGraph;
  mills: Mill[];
}

export interface MoveAction extends BaseAction {
  type: "move";
  from: PointID;
  to: PointID;
}

export interface PlaceAction extends BaseAction {
  type: "place";
  to: PointID;
}

interface ResetAction extends BaseAction {
  type: "reset";
}

type ActionType = "move" | "reset" | "place";
interface BaseAction {
  type: ActionType;
}

export type Action = MoveAction | ResetAction | PlaceAction;

const getOtherPlayer = (player: Player): Player => {
  return player === "a" ? "b" : "a";
};

/**
 * Validate a place action.
 * Expected scenarios:
 * - location must not be occupied
 *
 * Unexpected scenarios:
 * - current player must have >= 1 remaining man
 * - The game is not in phase 1
 */
const validatePlace = (action: PlaceAction, state: GameState): boolean => {
  const currentPlayer = state.turn.player;
  return (
    state.stateGraph[action.to].occupancy === undefined &&
    state.remainingMen[currentPlayer] >= 1 &&
    state.phase === 1
  );
};

/**
 * Validate a move action.
 * Expected scenarios:
 * - location must not be occupied
 * - Can only move the current players man
 *
 * Unexpected scenarios:
 * - current player must have no remaining man
 * - The game is not in phase 2
 */
const validateMove = (action: MoveAction, state: GameState): boolean => {
  const currentPlayer = state.turn.player;
  return (
    state.stateGraph[action.to].occupancy === undefined &&
    state.stateGraph[action.from].occupancy === state.turn.player &&
    state.remainingMen[currentPlayer] === 0 &&
    state.phase === 2
  );
};

/**
 * Tell whether or not the selection of `pointID` is valid. To be used externally by UI to allow/disallow the selection of a point
 */
export const isValidSelection = (
  pointID: PointID,
  state: GameState
): boolean => {
  return state.stateGraph[pointID].occupancy === state.turn.player;
};

/**
 * Determine if the game state is in the next phase
 */
const isNextPhase = (state: GameState): boolean => {
  switch (state.phase) {
    // Phase 1 moves to phase 2 when there are no more remaining men
    case 1:
      return Object.values(state.remainingMen).every((rm) => rm === 0);

    // TODO: Phase 2 moves to phase 3 when...
    case 2:
      return false;

    // There is no phase 4, so the game can never advance from 3
    case 3:
      return false;

    // All phases were covered above, so if we get here, something went wrong
    default:
      throw new Error(
        `An invalid phase value of ${state.phase} was encountered in isNextPhase`
      );
  }
};

const incrementPhase = (phase: Phase): Phase => {
  const nextPhase = phase + 1;

  // This range should match the range defined in the Phase type
  if (nextPhase > 3 || nextPhase < 1) {
    throw new Error(
      `An attempt to increment phase to ${nextPhase} was made. This is outside its valid range`
    );
  }
  return nextPhase as Phase;
};

// TODO -- this is not detecting repeat mills
const updateMills = (state: GameState): { newMill: boolean; mills: Mill[] } => {
  let newMill = false;
  const newMills = state.mills.map((mill) => {
    // Leave occupied mills as is
    if (mill.occupancy) {
      return mill;
    }

    // Grab the stateGraph occupancy of the first point in the mill
    const firstOcc = state.stateGraph[mill.points[0]].occupancy;

    // There can be no mill if the first point in the line is unoccupied, leave it as is
    if (!firstOcc) {
      return mill;
    }

    // Then let's check if the stateGraph has the same occupancy as first along the millLine
    const isMill = mill.points.every((pointID) => {
      return state.stateGraph[pointID].occupancy === firstOcc;
    });

    // Remember that we found a new mill so we can report it for return
    if (isMill) {
      newMill = isMill;
    }

    // If we found a new mill, update the mill list
    return isMill ? { ...mill, occupancy: firstOcc } : mill;
  });
  return { newMill: newMill, mills: newMills };
};

const nextStateAfterPlace = (state: GameState, action: PlaceAction) => {
  const currentPlayer = state.turn.player;
  const otherPlayer = getOtherPlayer(currentPlayer);

  // Validate the place action
  // TODO: How do we communicate the correct thing to do?
  // TODO Should we validate before even allowing the action?
  if (!validatePlace(action, state)) {
    console.log("Invalid place action");
    return state;
  }

  const nextState = {
    ...state,
    stateGraph: {
      ...state.stateGraph,

      // Occupy the "to" location with the player who made this play
      // TODO: check that it was valid
      [action.to]: {
        ...state.stateGraph[action.to],
        occupancy: currentPlayer,
      },
    },
    // When a play is made, the count increments and it becomes the other players turn
    turn: {
      player: otherPlayer,
      count: state.turn.count + 1,
    },

    // Remove 1 man from the current players remaining men
    remainingMen: {
      ...state.remainingMen,
      [currentPlayer]: state.remainingMen[currentPlayer] - 1,
    },
  };

  // Update the mills in game state
  // TODO - use mills to determine if current player can remove an opponents man
  const { newMill, mills } = updateMills(nextState);
  if (newMill) console.log("newmill");
  const newState = newMill ? { ...nextState, mills: mills } : nextState;

  // Check if the new state moves the game into the next phase
  return isNextPhase(newState)
    ? { ...newState, phase: incrementPhase(state.phase) }
    : newState;
};

const nextStateAfterMove = (state: GameState, action: MoveAction) => {
  const currentPlayer = state.turn.player;
  const otherPlayer = getOtherPlayer(currentPlayer);

  // Validate the move action
  // TODO: How do we communicate the correct thing to do?
  // TODO Should we validate before even allowing the action?
  if (!validateMove(action, state)) {
    console.log("Invalid move action");
    return state;
  }

  // TODO: check for win
  const nextState = {
    ...state,
    stateGraph: {
      ...state.stateGraph,

      // Occupy the "to" location with the player who made this play
      [action.to]: {
        ...state.stateGraph[action.to],
        occupancy: currentPlayer,
      },
      [action.from]: {
        ...state.stateGraph[action.from],
        occupancy: undefined,
      },
    },
    // When a play is made, the count increments and it becomes the other players turn
    turn: {
      player: otherPlayer,
      count: state.turn.count + 1,
    },
  };

  // Update the mills in game state
  // TODO - use mills to determine if current player can remove an opponents man
  const { newMill, mills } = updateMills(nextState);
  if (newMill) console.log("newmill");
  const newState = newMill ? { ...nextState, mills: mills } : nextState;

  // Check if the new state moves the game into the next phase
  return isNextPhase(newState)
    ? { ...newState, phase: incrementPhase(state.phase) }
    : newState;
};

const reducer = (state: GameState, action: Action): GameState => {
  switch (action.type) {
    // A placement in phase 1
    case "place":
      return nextStateAfterPlace(state, action);
    // A move in phase 2
    case "move":
      return nextStateAfterMove(state, action);
    case "reset":
      return initialState;
    default:
      throw new Error(
        `Unsupported action in encountered in useGameState: ${action}`
      );
  }
};

/**
 * A reducer like hook which holds the entire state of the game
 */
export const useGameState = () => {
  return React.useReducer(reducer, initialState);
};
